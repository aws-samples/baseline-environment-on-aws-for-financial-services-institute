// CloudWatch SyntheticsのCanary用スクリプト
// CDKの制約上このようなフォルダ構造 (nodejs/node_modules/index.js) を取っている
// https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_synthetics-readme.html#configuring-the-canary-script

const synthetics = require('Synthetics');
const log = require('SyntheticsLogger');
const { randomBytes } = require('crypto');
const { setTimeout } = require('timers/promises');
const syntheticsConfiguration = synthetics.getConfiguration();

const baseUrl = process.env.BASE_URL;

const fetchWithSynthetics = async (url, init, stepName) => {
  const parse = new URL(url);
  const requestOptions = {
    hostname: parse.hostname,
    method: init.method ?? 'GET',
    path: parse.pathname,
    port: parse.port != '' ? parse.port : parse.protocol == 'https:' ? 443 : 80,
    protocol: parse.protocol,
    headers: init.headers,
    body: init.body,
  };

  let responseBody = '';
  let status;
  const fetchCallback = async (res) => {
    return new Promise((resolve, reject) => {
      status = res.statusCode;
      res.on('data', (d) => {
        responseBody += d;
      });

      res.on('end', () => {
        resolve();
      });
    });
  };

  await synthetics.executeHttpStep(stepName ?? `${requestOptions.method} ${parse.pathname}`, requestOptions, fetchCallback);
  return {
    ok: status >= 200 && status <= 299,
    status: status,
    json: async () => JSON.parse(responseBody),
    text: async () => responseBody,
  };
};

const waitForTxSuccess = async (accountId, txId) => {
  await setTimeout(500);
  const res = await fetchWithSynthetics(`${baseUrl}/transaction/${txId}`, {
    headers: {
      X_ACCOUNT_ID: accountId,
      'Content-Type': 'application/json',
    },
  },
    // Because stepName is used for CloudWatch metrics dimension, it should not include a random string.
    "GET /transaction/:txId");
  if (!res.ok) {
    throw new Error(`Error on getTx - ${res.status} ${await res.text()}`);
  }
  const json = await res.json();
  txStatus = json.status;
  switch (txStatus) {
    case 'status#pending': {
      return await waitForTxSuccess(accountId, txId);
    }
    case 'status#rollback': {
      throw new Error(`Error on getTx - transaction ${accountId} ${txId} was rolled back`);
    }
    case 'status#success': {
      return;
    }
    default: {
      throw new Error(`Error on getTx - invalid status ${JSON.stringify(json)}`);
    }
  }
};

const apiCanaryBlueprint = async function () {
  // https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library_Nodejs.html#CloudWatch_Synthetics_Library_SyntheticsConfiguration
  syntheticsConfiguration.setConfig({
    restrictedHeaders: [],
    restrictedUrlParameters: [],
    includeRequestHeaders: true,
    includeResponseHeaders: true,
    includeRequestBody: true,
    includeResponseBody: true,
    logRequestBody: true,
    logRequestHeaders: true,
    logResponseBody: true,
    logResponseHeaders: true,
  });

  const accountId = randomBytes(10).toString('hex');
  {
    // deposit some money
    const res = await fetchWithSynthetics(`${baseUrl}/transaction/deposit`, {
      method: 'POST',
      headers: {
        X_ACCOUNT_ID: accountId,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        quantity: 1000,
      }),
    });
    if (!res.ok) {
      throw new Error(`Error on deposit - ${res.status} ${await res.text()}`);
    }
    const json = await res.json();
    const txId = json.transactionId;
    if (txId == null) {
      throw new Error(`Error on deposit - transactionId was not found ${JSON.stringify(json)}`);
    }
    await waitForTxSuccess(accountId, txId);
  }

  {
    // withdraw some money
    const res = await fetchWithSynthetics(`${baseUrl}/transaction/withdraw`, {
      method: 'POST',
      headers: {
        X_ACCOUNT_ID: accountId,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        quantity: 50,
      }),
    });
    if (!res.ok) {
      throw new Error(`Error on withdraw - ${res.status} ${await res.text()}`);
    }
    const json = await res.json();
    const txId = json.transactionId;
    if (txId == null) {
      throw new Error(`Error on withdraw - transactionId was not found ${JSON.stringify(json)}`);
    }
    await waitForTxSuccess(accountId, txId);
  }

  return 'success';
};

exports.handler = async () => {
  return await apiCanaryBlueprint();
};
